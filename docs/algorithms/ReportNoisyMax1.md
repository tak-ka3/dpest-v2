# ReportNoisyMax1

## アルゴリズムの説明

ReportNoisyMax1は、Report Noisy Max機構の正しい実装です。入力ベクトルの各要素にLaplaceノイズを追加し、最大値を持つインデックス（argmax）を返します。

**出典**:
> Zeyu Ding, Yuxin Wang, Guanhong Wang, Danfeng Zhang, and Daniel Kifer. 2018.
> Detecting Violations of Differential Privacy. CCS 2018.
> Algorithm 5

**アルゴリズム**:
1. 入力ベクトル $q = (q_1, q_2, \ldots, q_m)$ を受け取る
2. 各要素 $i$ に対して、独立にLaplaceノイズ $\eta_i \sim \text{Lap}(2/\varepsilon)$ を追加
3. ノイズ付きベクトルの最大値を持つインデックスを返す: $\text{argmax}_i (q_i + \eta_i)$

**数式**:

$$
M(D) = \text{argmax}_i (q_i + \text{Lap}(2/\varepsilon))
$$

**プライバシー保証**: クエリの $L_\infty$ 感度が1の場合、 $\varepsilon$ -DPを満たします。

**隣接性の定義**: $\|\cdot\|_\infty$ （L∞ノルム）
- 2つのデータベース $D_1, D_2$ が隣接： $\max_i |D_1[i] - D_2[i]| \leq 1$ （各要素が最大1の変化）

## モード

**解析モード**

各要素に対してLaplace分布を格子近似し、Argmax演算を適用します。Argmax演算は累積分布関数（CDF）を使用して効率的に計算されます。

## プライバシー損失結果

| 項目 | 値 |
|------|-----|
| 入力サイズ | 5 |
| 推定 ε | 0.1069 |
| 理論 ε | 0.10 |
| 誤差 | +0.0069 (6.9%) |
| 実行時間 | 2.75秒 |

**データソース**: `docs/privacy_loss_report.md`

## 理論的な計算量

### 解析モード

**全体計算量**: $O(m^2 \times g^2)$

**内訳**:
1. **Laplace分布の生成**: $O(m \times g)$
   - $m=5$ 個の独立なLaplace分布を生成
   - 各分布は格子点 $g=1000$ 上で評価
2. **Add演算（各要素に対する畳み込み）**: $O(m \times g \log g)$
   - $m=5$ 回の独立な畳み込み
   - 各畳み込みは $O(g \log g)$ （FFTベース）
3. **Argmax演算**: $O(m^2 \times g^2)$ ← **支配的**

   各インデックス $i$ が最大となる確率を計算すると、 $P(\text{argmax} = i) = \int_{-\infty}^{\infty} f_{Z_i}(z) \prod_{j \neq i} F_{Z_j}(z) \, dz$ となる。ここで $f_{Z_i}$ は $Z_i = q_i + \eta_i$ の確率密度関数、 $F_{Z_j}$ は累積分布関数（CDF）

   **計算量の内訳**:
   - 外側ループ（各インデックス $i$ ）: $m=5$ 回
   - 内側ループ（他の分布 $j$ ）: $m-1=4$ 回
   - 各CDF計算（`_compute_cdf_on_grid`）: $O(g^2)$ 
      - x_gridの各点（ $g$ 個）について、累積和をtrapzで計算（ $O(g)$ ）
     - 二重ループ構造: 外側 $g$ 回 × 内側 $O(g)$ = $O(g^2)$

**実効計算量**（ $m=5$ , $g=1000$ ）:

$$
m^2 \times g^2 = 25 \times 10^6 = 2.5 \times 10^7 \text{ 演算}
$$

**参照**: `docs/OPERATION_COMPLEXITY_ANALYSIS.md` - Argmax演算（連続分布）: 3.1節

## 理論的な誤差（精度）

### 解析モードの誤差構造

Argmax演算は、各インデックスが最大となる確率を計算するため、誤差の構造が複雑です。

#### 1. 切断誤差（Truncation Error）

各Laplace分布（スケール $b = 2/\varepsilon = 20$ ）の切断誤差:

$$
\text{err}_{\text{trunc}} \approx e^{-\varepsilon R / 2} = e^{-0.1 \times 500 / 2} = e^{-25} \approx 10^{-11}
$$

（無視できる）

#### 2. CDF計算誤差

Argmax演算では、各インデックスが最大となる確率を計算するために、累積分布関数（CDF）を $m \times (m-1)$ 回計算します。各CDF計算には以下の誤差が含まれます：

- **台形則誤差**: $O(L^3/g^2) \approx O(10^{-3})$ （各CDF計算）
- **累積誤差**: $m \times (m-1) \times O(10^{-3}) = 20 \times O(10^{-3}) = O(10^{-2})$ 

#### 3. 補間誤差（Interpolation Error）

$$
\text{err}_{\text{interp}} = O(1/g^2) = O(10^{-6})
$$

**総誤差**: CDF計算の累積誤差 $O(10^{-2})$ が支配的です。

**実測誤差との一致**:
- 理論誤差: $O(10^{-2})$
- 実測誤差: $0.0069 \approx 7 \times 10^{-3}$
- 一致度: 良好

## 理論と実験結果の比較分析

### 精度の分析

| 項目 | 理論値 | 実測値 | 差分 |
|------|--------|--------|------|
| ε | 0.10 | 0.1069 | +0.0069 |
| 相対誤差 | - | 6.9% | - |

**評価**:
- 推定精度は **良好**（相対誤差 6.9%）
- 理由: Argmax演算が $m^2$ 回のCDF計算を必要とし、誤差が累積
- 理論誤差 $O(10^{-2})$ と実測誤差 $6.9\% = 0.0069$ は一致

### 実行時間の分析

**計算量**: $O(m^2 \times g^2)$ - Argmax演算が支配的（ $g^2$ の項）

**演算数**: $m=5, g=1000$ の場合、約 $2.5 \times 10^7$ 回の演算

**実行時間**: 2.75秒

### 比較: 解析モード vs サンプリングモード

ReportNoisyMax1では**解析モードを使用**しています。以下では、現在のサンプリングモード実装との比較を行います。

#### 【計算量の比較】

**解析モード**: $O(k \times m^2 \times g^2)$
- **実装詳細**:
  - $k=14$: 隣接ペア数7 × 2（PとQ）
  - Argmax演算: $m \times (m-1)$ 回のCDF計算、各 $O(g^2)$
  - $m=5, g=1000$ の場合: $k \times 2.5 \times 10^7 = 3.5 \times 10^8$ 演算
- **実測時間**: 2.75秒（7ペアの合計）

**サンプリングモード（現在の実装）**: $O(k \times N \times d)$
- **実装詳細**:
  - $k=14$: 隣接ペア数7 × 2（PとQ）
  - $N$: サンプル数
  - $d$: 演算の深さ（Argmax → Add → Laplace のネスト）
- **実測時間**:
  - N=10,000: 6.32秒（7ペアの合計）
  - N=100,000: 15.31秒（7ペアの合計）
  - N=1,000,000: 104.55秒（7ペアの合計）

#### 【精度の比較】

**解析モード**:
- **実測精度**: 相対誤差 6.9%（推定ε=0.1069 vs 理論ε=0.10）
- **誤差の内訳**:
  - CDF計算の累積誤差: $O(10^{-2})$（支配的）
  - 台形則誤差: $O(10^{-3})$ × 20回 = $O(10^{-2})$
  - 補間誤差: $O(10^{-6})$（無視可能）

**サンプリングモード（現在の実装）**:
- **理論精度**: モンテカルロ誤差 $O(1/\sqrt{N})$
  - $N=1,000,000$: 理論誤差 $\approx 0.1\%$
- **実測精度**: N=100,000で相対誤差-3.7%（推定ε=0.0963 vs 理論ε=0.10）
  - N=1,000,000でも-3.7%と変わらず、系統的な偏りが存在
  - **偏りの原因**: 隣接ペアのカバレッジ不足（7つの固定パターンのみでworst-caseを捉えていない）

【**精度と実行時間の比較表**】

| モード | サンプル数/格子点数 | 理論誤差 | 実測誤差 | 実測時間 |
|--------|------------------|---------|---------|---------|
| 解析 | $g=1000$ | ~1% | 6.9% | 2.75秒 |
| サンプリング（N=10K） | $N=10,000$ | ~1.0% | -7.4% | 6.32秒 |
| サンプリング（N=100K） | $N=100,000$ | ~0.32% | -3.7% | 15.31秒 |
| サンプリング（N=1M） | $N=1,000,000$ | ~0.1% | -3.7% | 104.55秒 |

#### 【なぜ解析モードを使用しているか】

1. **実行速度**:
   - 解析モード（2.75秒）の方がサンプリングモード（N=10Kで6.32秒）より高速
   - サンプリングモードのベクトル化は技術的に困難（詳細は後述の「サンプリングモードの性能課題」を参照）

2. **決定論的な結果**:
   - 解析モード: 同じ入力に対して常に同じ結果
   - サンプリングモード: 乱数に依存して結果が変動

#### 【サンプリングモードの性能課題】

現在のサンプリングモード実装には以下の課題があります：

1. **ベクトル化の困難性**:
   - 宣言的なアルゴリズム定義（`Argmax(Add(values, noise))`）から、ベクトル化されたNumPyコードへの自動変換が困難
   - 条件分岐、ループ、共通依存関係の管理が複雑

2. **関数呼び出しのオーバーヘッド**:
   - サンプル1つ生成するのに、ネストした関数呼び出しが連鎖
   - ReportNoisyMax1の場合: `Argmax._sample_func` → 各要素の `Add._sample_func` (m回) → 各要素の `Laplace._sample_func` (m回)
   - 総関数呼び出し数: N × (1 + m + m²) ≈ 31,000,000回 (N=1M, m=5)
   - 比較: 直接実装では N × 2 ≈ 2,000,000回（約15倍の差）

3. **一般性とのトレードオフ**:
   - 現在の実装は18種類のアルゴリズム全てに対応する汎用設計
   - 個別にベクトル化実装を書けば高速化可能だが、保守性が低下

### 比較: DP-Sniper vs StatDP vs DPEST

| 手法 | 推定 ε | 実行時間 | 相対速度 |
|------|--------|----------|----------|
| DP-Sniper | 0.092 | 22秒 | 1x |
| StatDP | 0.092 | 46秒 | 0.48x |
| DPEST（解析） | 0.1069 | 2.75秒 | **8x** |

**結論**:
1. **精度**: DPESTは理論値に最も近い（誤差6.9%）
   - DP-Sniper: 誤差8% (0.10 → 0.092)
   - StatDP: 誤差8% (0.10 → 0.092)
   - DPEST（解析）: 誤差6.9% (0.10 → 0.1069)
2. **速度**: DPESTは他手法と比較して **8-17倍高速**
