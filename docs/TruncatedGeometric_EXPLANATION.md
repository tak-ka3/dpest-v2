この `TruncatedGeometricMechanism` は、Balcer & Vadhan (2018)「Differential Privacy on Finite Computers」 の **Algorithm 4.8 “GeoSample”** を Python で実装したものです。
このアルゴリズムは、**有限精度計算機上でも差分プライバシーを保証するように設計された「切り詰め幾何分布 (Truncated Geometric Mechanism)」** を実現します。

---

## 🔹 背景：有限計算機上の差分プライバシー問題

通常の差分プライバシー機構（例：Laplace, Geometric）は、**実数値の乱数生成** や **指数関数的な重み** を扱いますが、
有限精度（整数や有限bit演算）では端数丸めやオーバーフローが生じ、理論通りの DP 性質が破綻します。

Balcer & Vadhan は、有限計算機でも厳密な DP を保てるように、
**整数演算だけで動作する確率機構**（GeoSample）を設計しました。

---

## 🔹 アルゴリズム概要

### 入力・出力

* 入力:

  * `c`: 集計クエリの真のカウント（0 ≤ c ≤ n）
  * `n`: 個体数（カウント範囲の上限）
  * `ε`: プライバシーパラメータ

* 出力:

  * 差分プライバシーを満たす整数値（カウントのノイズ付き出力）

### 直感的な説明

1. **真のカウント c** を中心にした「幾何分布ノイズ」を加える。
2. ただし有限精度ゆえに無限の裾野を持つ分布を扱えないため、
   範囲 `[0, n]` に **切り詰め (truncate)**。
3. 結果として、整数演算のみでDPを保証する「離散的・有限なサンプリングアルゴリズム」が得られる。

---

## 🔹 コードの流れ

### ① 初期化 (`__init__`)

```python
self.k = math.ceil(math.log(2.0 / eps))
self.d = int((2^(k+1) + 1) * (2^k + 1)^(n - 1))
```

* `k` は ε に依存する「スケーリング係数」で、
  `2^(-k)` がノイズ強度を支配します。
* `d` は **全体の確率質量のスケーリング定数** です。
  （確率を整数化するために用いられる）

> ✅ 理論上、GeoSample(eps, n) は
> `ln(1 + 2^-ceil(ln(2/eps)))`-DP を保証します。
> つまり有限整数演算でも近似ではなく厳密なDP。

---

### ② `m()`：メカニズムの主処理

```python
f = self._compute_f(c.item(0))
u = np.random.randint(1, self.d + 1, size=n_samples)
```

1. `_compute_f()` により、累積分布関数 F(z)（整数スケーリング版）を構築。
2. 一様乱数 `u ∈ [1, d]` を生成。
3. 各 `u` に対して、最小の `z`（0 ≤ z ≤ n）で `F(z) ≥ u` を満たすものを選ぶ。
   → これは逆変換サンプリングに相当。

---

### ③ `_compute_f()`：整数スケーリングされた累積分布の構築

```python
z_le_c = np.atleast_2d(range(0, c))
z_geq_c = np.atleast_2d(range(c, self.n))
```

#### 区間1: `[0, c)`

```python
a = 2^(k * (c - z))
b = (2^k + 1)^(n - (c - z))
f[:c] = a * b
```

* `c` より小さい出力値に対して、減衰する幾何確率を加算。

#### 区間2: `[c, n)`

```python
a = 2^(k * (z - c + 1))
b = (2^k + 1)^(n - 1 - (z - c))
f[c:n] = d - a * b
```

* `c` より大きい出力値に対して、右側の幾何尾部を反映。
* `f[n] = d` で全確率を正規化。

---

### ④ サンプリング部

```python
for idx in reversed(range(0, self.n + 1)):
    z[f[idx] >= u] = idx
```

`f` は累積分布を整数で表しており、
`u` を下回る最小の `z` を求めることで確率に従ったサンプリングを実現します。

---

## 🔹 理論的性質

* **DP保証**
  理論上、`GeoSample(eps, n)` は次を満たします：
  [
  \text{Privacy parameter } \epsilon' = \ln(1 + 2^{-\lceil \ln(2 / \epsilon) \rceil})
  ]
  つまり、通常の ε よりも少し小さい厳密DPを保証。

* **有限精度安全性**
  乱数は整数演算 (`randint`) で行い、
  浮動小数の丸め誤差を完全に排除。

* **複雑性**
  `O(n)` の計算で、`n` が小さい場合に実用的。
  `n` が大きいと `d` が急増（オーバーフロー）する。

---

## 🔹 まとめ

| 項目    | 内容                                                                 |
| ----- | ------------------------------------------------------------------ |
| 論文    | Balcer & Vadhan (2018), *Differential Privacy on Finite Computers* |
| 実装対象  | Algorithm 4.8 “GeoSample”                                          |
| 機構の目的 | 有限精度計算機上での厳密DP保証                                                   |
| DP保証  | ( \ln(1 + 2^{-\lceil \ln(2/\epsilon) \rceil}) )-DP                 |
| 出力範囲  | ([0, n])                                                           |
| 特徴    | 整数演算・切り詰め幾何分布・逆変換サンプリング                                            |
| 注意点   | `n` が大きい or `ε` が小さいと整数オーバーフローの危険                                  |


---

良い質問です。この部分は、**GeoSample のコアとなる「逆変換サンプリング」(inverse transform sampling)** を、**整数演算で実装している**箇所です。
以下では、何をしているのかを数式レベル・直感レベルの両方で解説します。

---

## 🔹 目的：累積分布関数 F からのサンプリング

前段で `_compute_f()` によって作られた `f` は、
確率分布の「累積分布関数 (CDF)」を整数スケーリングしたものです：

[
F(z) = f[z] / d
]

つまり、

* `f[z]` は、値 `z` 以下の確率質量の総和 × `d`
* `d` はスケーリング定数（分母）

---

## 🔹 手順の概要

```python
u = np.random.randint(1, self.d + 1, size=n_samples)
```

ここで乱数 `u` は、一様分布 ( U(1, d) ) から生成されます。
この `u` は「確率質量の位置」を整数で表しています。

そして次のループ：

```python
z = np.empty(n_samples)
for idx in reversed(range(0, self.n + 1)):
    z[f[idx] >= u] = idx
```

これは、**各サンプル u に対して「f[idx] ≥ u となる最小の idx」を求める**処理です。
この idx が最終的な出力 `z` です。

---

## 🔹 処理の流れを段階的に追う

### ① 例：簡単な状況

仮に `n = 3`、`d = 100`、`f = [20, 50, 80, 100]` の場合を考えましょう。

| z | f[z] | F(z)=f[z]/100 |
| - | ---- | ------------- |
| 0 | 20   | 0.2           |
| 1 | 50   | 0.5           |
| 2 | 80   | 0.8           |
| 3 | 100  | 1.0           |

これは、「z = 0 が 20%の確率」「z = 1 が 30%」「z = 2 が 30%」「z = 3 が 20%」の分布を意味します。

---

### ② サンプリングの考え方

通常のCDFサンプリングでは：

1. 一様乱数 ( u \sim U(0,1) ) を取る。
2. ( F(z-1) < u \le F(z) ) を満たす最小の z を探す。

整数化されている場合はこれを：

[
f[z-1] < u \le f[z]
]
で表すことになります。

---

### ③ コードでの動き

`for idx in reversed(range(0, self.n + 1)):` は
z を大きい方から順に見ていきます（3→2→1→0）。

例えば `u = 72` の場合：

| idx | f[idx] | f[idx] >= u? | z[u]=idxに設定? |
| --- | ------ | ------------ | ------------ |
| 3   | 100    | ✅            | z=3 に設定      |
| 2   | 80     | ✅            | z=2 に上書き     |
| 1   | 50     | ❌            | 変化なし         |
| 0   | 20     | ❌            | 変化なし         |

最終的に `z = 2` になります。

つまり「**最初に f[idx] ≥ u となった idx の中で最小のもの**」が採用されます。
逆順に回しているのは、「上書きして最終的に最小の idx を残す」ためです。

---

## 🔹 なぜ逆順で回すのか？

もし順方向（0→n）でループした場合、
`z[f[idx] >= u] = idx` が実行されると、後でより大きな `idx` に再び上書きされてしまいます。

逆順（n→0）で回すことで、最初に `True` になった `idx`（つまり最小のz）で確定させられます。

---

## 🔹 ベクトル化の理由と限界

このコードは Python/Numpy で全サンプルを一度に扱います。

* `u` はベクトル（長さ = n_samples）
* `f[idx] >= u` は要素ごとの比較 → Booleanベクトル
* その結果に基づいて `z` を一括更新

つまり、ループは `idx` のみを回しており、`u` の各成分は同時に処理しています。
そのため `n` が小さい場合は十分高速です。
（`n` が大きい場合は O(n × n_samples) になるため重くなる）

---

## 🔹 まとめ

| ステップ                   | 処理内容          | 意味        |
| ---------------------- | ------------- | --------- |
| `f = _compute_f(c)`    | 累積分布 (整数) を構築 | 確率分布の形を定義 |
| `u = randint(1, d+1)`  | 一様整数乱数生成      | 確率軸上の乱数点  |
| ループで `f[idx] >= u` を確認 | u に対応する z を探索 | 逆変換サンプリング |
| 逆順ループ                  | 最小 z を正確に選択   | オーバーライド防止 |

---
