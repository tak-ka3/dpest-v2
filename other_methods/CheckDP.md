CheckDPの手法概要
CheckDPは、確率的プログラム（差分プライバシー機構）のソースコードと主張されるプライバシー予算ϵを入力として受け取り、その機構がϵ-差分プライバシーを満たすことを自動で証明するか、あるいは精確な反例（プライバシー違反の入力例）を発見する統合的アプローチです。差分プライバシーの詳細な背景説明は省略し、以下ではCheckDPの具体的な技術内容（プログラム変換、アラインメントテンプレート生成、verify-invalidateループ、証明および反例の自動生成、システム実装と使用ツール）に焦点を当てて解説します。
プログラム変換（静的解析）
まずCheckDPは、与えられた確率的アルゴリズム（機構）を静的解析によって非確率的な検証用プログラムに変換します。この変換では、オリジナルのソースコードに以下のような改変が施されます：
乱数の決定論的扱い: 元の確率的処理である乱数サンプリング文（例: η := Lap(2/ϵ)）を非確率的な入力読み込みに置き換えます。乱数は外部から与えるsampleという追加入力から読み取ることで、プログラムを決定論的にし（乱数シードを固定するイメージ）、後続の符号実行ツールで解析可能にします。
アラインメントテンプレートの挿入: 各乱数サンプリング箇所に対し、アラインメントテンプレート（後述）の形式で穴あきの補正項を導入します。これは2つの関連する実行（隣接する入力に対する2回の実行）における乱数の対応付けを表現するための式で、内部に未知のパラメータθ（シータ）を含みます。θは全テンプレートの係数をまとめたもので、CheckDPではこれを一種の関数引数（追加入力）として扱い、後で自動的に適切な値を探索します。
プライバシーコスト変数の導入: プログラム全体の累積プライバシーコストを追跡する特別な変数vϵを追加し、必要な箇所（乱数の使用箇所や出力箇所など）でこのコスト変数を更新します。例えばLaplace機構では、2つの実行間で乱数に差が生じた場合に生ずるプライバシーコスト|Δ|/r（Δは乱数値の差、rはLaplaceのスケール）をvϵに加算する形で更新します。このように静的解析によって各操作の寄与分を計算し、プライバシー予算消費量を逐次積算します。
アサーション（断言）の挿入: 差分プライバシーの条件を検査するアサーションをプログラム中に挿入します。具体的には、最終的な累積コストvϵが与えられたϵを超えないことを保証するチェックや、各局面で差分プライバシー違反となり得る事象が起きた場合にassert失敗するチェックをコード中に埋め込みます。例えば、2つの入力に対する出力の確率比が許容範囲を超える場合にassertが発動する、といった箇所です。こうしたアサーションが一度も失敗しなければ（すなわち全ての実行パスでプライバシー条件が満たされれば）、元の機構は差分プライバシーを満たすことが論理的に保証されます。逆に言えば、アサーション失敗はプライバシー違反の証拠になります。
以上の変換によって得られる**変換後プログラム M′**は、ランダム性を排除しており、かつθというパラメータによって「乱数の対応付け方（証明戦略）」を表現できる形になっています。このM′(inp, inp᾽, sample, θ)に対し「適切なθを見つけて全てのassertionを通過させられるか？」という問題に帰着することで、差分プライバシーの証明または反例探索を行うのがCheckDPのアプローチです。言い換えれば、「∃θ . ∀inp, inp᾽, sampleについてassertが失敗しない」ことを示せれば証明成功、逆に「∀θについてもあるinp, inp᾽, sampleでassertが失敗する」ならばそれが反例となります。
アラインメントテンプレートの生成
CheckDPの証明手法は**「ランダムネスのアラインメント（Randomness Alignment）」と呼ばれる概念に基づいています。これは2つの関連する実行において、対応する乱数の取り方を工夫（カップリング）することで出力分布の差を抑え、差分プライバシーを証明する技法です。CheckDPではこのアラインメントをテンプレート（ひな形）という形で自動生成し、未知パラメータθで表現しました。各乱数サンプリング命令η := Lap(r)ごとに、その乱数の2つの実行間での差をどのように補正（対応付け）するかを表す式Aをテンプレートとして用意します。テンプレートAは通常の数式の形をしていますが、中にはθという「穴」**（未定の係数）が含まれており、この値は後で最適なものが探索されます。 テンプレート生成の方法: 単純に考えれば、乱数ηのアラインメントAとして許される式は「任意の数値式」であり得ますが、探索の観点からあまりに表現力が高すぎると自動合成が困難です。逆にごく単純な定数で合わせるだけでは、多くの機構で証明ができません（例：後述のGapSVTでは乱数を常に同じ値に揃える定数アラインメントでは不十分でした）。そこでCheckDPは静的解析によって「アラインメントに関係しそうなプログラム上の条件式と変数」を抽出し、テンプレートをそれらに依存する線形式の組み合わせとして構築します。具体的には、以下の手順で各乱数ηのテンプレートAを生成します:
アラインメントに影響を及ぼし得る分岐条件の集合 Eを求めます。例えば、乱数ηがある条件式の結果によって利用のされ方が変わるなら、その条件式をEに含めます。
同様に、乱数の差に関係し得るプログラム変数の集合 Vを求めます。これは型システムによる距離変数の解析で得られます。CheckDPでは各変数に「2つの入力間での差分（距離）」を表すメタ変数を導入しており（例えば隣接する2つの入力間である変数xがどれだけ変わり得るかをbxで表す）、この環境Γを参照することでVに適切な差分変数を含めます。
テンプレートAを次の構造で組み立てます:
もし関連条件Eに複数の条件式がある場合、最初の条件e₀について**「e₀ ならば A{e₀} を、そうでなければ A{e₀} を使用」という条件付き式**を作ります（再帰的に残りの条件でも同様のネストを行います）。
最終的に条件をすべて考慮し終えたら、残った部分を線形和の式とします。つまり、A = θ₀ + θ₁·v₁ + θ₂·v₂ + ... + θ_n·v_n（v_iはVに含まれる各変数）という形で表し、θ₀,...,θ_nを新たな「穴」として導入します。こうすることでAはプログラム中の関連変数に線形に依存する柔軟な形になります。
このテンプレートAは、乱数ηの2回の実行間の差をどのように補正するかをパラメータ化したものです。例えば機構GapSVT（しきい値付きスパースベクトル法）の場合、第2の乱数η₂の正しいアラインメントは「if文の分岐によって“この乱数の差を1 - bq[i]にするか0にするか”を切り替える」必要がありました。CheckDPはこれをテンプレートとして表現し、実際に**「(q[i] + η₂ ≥ Tη) ? (θ[0] + θ[1]×T_bη + θ[2]×bq[i]) : (θ[3] + θ[4]×T_bη + θ[5]×bq[i])」という式（θ[0]～θ[5]は穴）を自動生成しています。ここでq[i] + η₂ ≥ Tηは分岐条件、T_bηはしきい値Tに加えたノイズη₁の差、bq[i]は2つの入力間でのクエリ値q[i]の差を表します。θの値次第でこの式は例えば「分岐成立時は1 - bq[i]、非成立時は0」という具体的なアラインメント式にもなり得ます（実際、正しい証明にはそのような値が割り当てられました）。このようにCheckDPはプログラム構造に応じたテンプレートを用意し、証明に必要な乱数の対応付け戦略**を一般的な形で表現できるようにします。テンプレート中の各θは当初は未定ですが、次の検証フェーズで適切な値が自動的に見つけられることになります。
verify-invalidateループの仕組み
CheckDPの中核は、証明用のパラメータθと反例となる入力Iの両方を交互に洗練させていく**「verify-invalidateループ」と呼ばれる探索アルゴリズムです。差分プライバシーの証明問題では、証明の候補（アラインメントθ）も無限の探索空間を持ち、また反例となる入力ペアIも無限に近い組み合わせが存在します。この双方の探索を効率良く行うために、CheckDPは検証側サブループ**（verify sub-loop）と無効化側サブループ（invalidate sub-loop）の二つを組み合わせたループを回します。これは従来プログラム合成で用いられるCEGIS（Counterexample Guided Inductive Synthesis, 反例誘導合成）に着想を得たものですが、CEGISが「解候補→反例→解候補→…」と一方向に繰り返すのに対し、CheckDPのループは双方向（bidirectional）である点が特徴です。すなわち、証明候補θと無効化入力Iの両方を内部で蓄積しながら交互に改良していき、最終的にどちらか一方を確定させる形になっています。Fig.4はこのループの概略図で、緑の矢印が検証サブループ（Proof Generation側）、青の矢印が無効化サブループ（Counterexample Generation側）を表しています。アルゴリズムはデフォルトの初期パラメータθ₀（例えば全て0に設定）から始まり、そこから順にθ₀, I₀, θ₁, I₁, θ₂, …というように証明候補θと見つかった無効化入力Iをペアで生成し続け、最終的に得られたθ_kまたはI_kを結果（証明または反例）として出力します。
検証サブループ (Verify Sub-loop)
検証サブループの目的は、「あるθの値で全てのassertionが常に通ること」を満たす具体的なθを見つけること、すなわち差分プライバシーの証明（アラインメント）の完成です。内部では次の2段階のフェーズを繰り返します。
無効化入力の探索 (Invalidating Input Generation): 現在の証明候補θᵢに対して、それでは不十分であることを示す入力Iᵢを探します。形式的には「∃(inp, inp᾽, sample)についてassertionが失敗する」ことを発見する作業です。CheckDPはこの探索にシンボリック実行ツールであるKLEEを利用し、θᵢを固定した状態でプログラムM′をシンボリックに実行させてassertion違反を起こす具体的入力Iᵢを見つけます。Iᵢは具体的には(inp_i, inp᾽_i, sample_i)という3つ組で、θᵢではこの入力ペアに対してプライバシー条件を満たせなかった（何らかのassertionがfalseになった）ことを意味します。もしKLEEによってそのような入力Iᵢが見つかれば、θᵢはまだ完全な証明ではないことが判明します。このIᵢを**「無効化入力」**と呼び、後述の無効化サブループでも利用します。仮に現在のθᵢでassertion違反が全く見つからなければ、証明候補θᵢは有望ですが、それが本当に全入力で大丈夫かは後述の検証ツールで確認します。
証明候補の更新 (Proof Generation): フェーズ1で得られた全ての無効化入力 {I₀, I₁, ..., I_i} を考慮に入れて、新たにθを調整します。具体的には、それらすべての入力についてassertionを通過させるようなθ_{i+1}を満たす解を探します。これは「∃ θについて M′(I₀, θ) ∧ M′(I₁, θ) ∧ ... ∧ M′(I_i, θ)」という充足可能性問題を解くことに相当します。言い換えれば、過去に見つかった複数の無効化入力それぞれに対し同時に有効な（assertionを失敗させない）アラインメントθを求めます。CheckDPでは、この問題もシンボリック実行やSATソルバを用いて解きます。例えばKLEEにθをシンボリック変数として持たせ、I₀...I_iを固定した複数の実行パスを用意してassertionを全て回避できるθを探索するといった手法が使われています（具体的な実装は非公開ですが、このようにして複数ケースを網羅するθの解を求めます）。見つかったθ_{i+1}は前段階よりも「強い」証明候補、すなわち以前は失敗した入力もカバーする改善版となります。CheckDPは初期θ₀（全0等のNull証明）から始め、フェーズ1と2を交互に繰り返すことでθをだんだん強化していきます。こうして無効化入力のリストが増えるほどθも洗練され、徐々に完全な証明に近づくわけです。
このループを繰り返し、ある時点でフェーズ1（無効化入力探索）が**「行き詰まる」（つまり、それ以上KLEEがassertion違反を発見できなくなる）ことがあります。その時得られているθ_iは「少なくともかなり多くの入力に対して成立している」証明候補と言えます。CheckDPはこのθ_iを最終候補とみなし、形式検証ツール（CPAChecker）に渡して全ての入力に対して本当にassertionが失敗しないか**（すなわち$\forall inp, inp', sample. M′(inp, inp', sample, θ_i)$が成り立つか）をチェックします。CPACheckerはプログラム検証器としてアサーション違反が理論上存在しないことを確認できるツールです。ここで検証がパスすれば、θ_iが差分プライバシーの正式な証明（乱数アラインメントの完成形）となります。実際、CheckDPはベンチマーク機構GapSVTに対してθ = {1, 1, 0, -1, 0, 0, 0}という値を自動的に見つけ出し、CPACheckerによりGapSVTがϵ-差分プライバシーを満たすことを証明しました。 万一、CPACheckerで検証に失敗した場合（θ_iでは網羅できていない入力がある場合）、CPACheckerは具体的な反例入力を生成して知らせてくれます。CheckDPはその場合、その入力を新たな無効化入力Iに加えてループを継続し、再度θを改善します（もっとも、評価では検証段階で失敗するケースは起きませんでした）。
無効化サブループ (Invalidate Sub-loop)
一方で、検証サブループ側でθの改善が行き詰まった場合（つまり、ある無効化入力に対してどんなθを当てはめてもassertionを全て通過させることができないと推測される場合）、CheckDPは無効化サブループに移行します。無効化サブループの目標は、「どんなθでも対処不可能」な決定的反例入力Iを一つ構築することです。こちらも2つのフェーズからなります。
証明候補の探索 (Proof Candidate Generation for given input): 手持ちの無効化入力候補$I$に対して、逆にそれを対処できるθが存在するかを調べます。形式的には「∃ θ . M′(I, θ)」すなわち「この特定の入力Iについてassertionを全部通すθがあるか？」をチェックします。これもKLEEを用いて、今度は入力Iを固定しθをシンボリックにして探索することで行います。もし何らかのθが見つかるなら、そのIは実は完全な反例ではありません。そこで見つかったθ（もし存在すれば）を新たな証明候補としてリストに加え、再び今度は「複数のθに対して破れる入力を探す」フェーズ2に進みます。反対に、ここでθが一つも見つからない場合、現時点のIは「どんなθでもalignできない（カバーできない）入力」である可能性が高まります。その場合はこのIを反例候補として保留し、次のステップに進みます。無効化サブループは、検証サブループで最後に見つかった無効化入力（最も「強敵」だった入力）からスタートし、それを$I_0$として上記のチェックを行います。
反例入力の更新 (Counterexample Generation): フェーズ1で「その入力Iはまだθによって救える」と判明した場合、次に今まで見つかった証明候補θ₁,...,θ_iを全て破る新たな入力Iを探す作業を行います。形式的には「∃ Iについて ¬M′(I, θ₁) ∧ ¬M′(I, θ₂) ∧ ... ∧ ¬M′(I, θ_i)`」を満たすIを見つける問題です。これは「現在蓄えられた全てのアラインメント戦略θでは対応不能な入力Iを見つけよ」という意味であり、検証サブループの探索と双対的な関係にあります。CheckDPではこの探索にもKLEEを使用し、複数のθ_iに対してassertionが失敗する経路を同時に探索するようなアプローチで新たなIを見つけ出します。もし見つかればそれを新たな無効化入力$I_{new}$としてリストに追加し、再度検証サブループに戻ってθを改善するサイクルを再開します（これがループの統合です）。一方、ここで探索が行き詰まる、つまりそれ以上新しいIが見つからない場合には、直前のIが「他のどのθでも防げない決定的な反例候補」である公算が大きくなります。
以上のようにverifyサブループとinvalidateサブループはお互いに結果（θやI）を渡し合いながら交互に実行され、「θが改善できなくなったら無効化側でIを探し、Iが見つからなくなったら証明側でθを探す」というループを構成しています。この双方向の探索により、CheckDPは証明と反例の両方の空間を効率よく絞り込んでいきます。最終的に、以下の2通りの停止条件のどちらかが満たされます。
証明成功: ある時点で無効化入力がこれ以上見つからず（verify側フェーズ1が停止）検証ツールでθが確証された場合。→ その時点のθが差分プライバシー証明（ランダム化機構に対するアラインメントの実証）となります。
反例発見: ある時点でどんなθでも対応不可能な入力Iが存在することが判明（invalidate側フェーズ1が停止）した場合。→ そのIを用いて差分プライバシー違反の反例を構築します。
後者の場合、CheckDPは得られた反例入力Iについて確率計算ツール（PSI）を用いて厳密に検証します。PSIはシンボリック確率推論により、当該入力ペアに対する機構の出力分布の差を正確に計算できるツールです
users.cs.duke.edu
。CheckDPはPSIによって、そのIに対し本当にプライバシー損失が主張されたϵを上回るか（すなわち $P[M(x) ∈ O] / P[M(x') ∈ O] > e^ϵ$ となる出力事象Oが存在するか）を確認します。もし確認されれば、それが確かな反例としてユーザに提示されます。例えばBadGapSVT（GapSVTの不正な変種）に対してCheckDPが発見した反例は、「しきい値T=0, クエリ回数N=1、隣接する2つの入力データ q と q᾽ の差分がq = [0,0,0,0,0], q᾽ = [1,1,1,1,-1] で、出力のあるビットパターン [0,0,0,0,1] が生じる場合」というものです。この具体例に対しPSIで計算したところ、プライバシー損失が主張ϵを超えていることが確認され、反例として確定しました。
証明と反例の自動生成方法
上述のverify-invalidateループにより、CheckDPは正しい機構に対しては証明を、誤った機構に対しては反例を一貫した枠組みで自動生成できます。証明が得られた場合、それは変換後プログラムのパラメータθの具体値として表されます。θは各乱数に対するアラインメント式中の係数の集合でしたので、証明結果は「乱数η₁にはこの対応付けを、η₂にはこの対応付けを…」という形のアラインメント戦略そのものになります。例えば前述のGapSVTに対するθ = {1,1,0,-1,0,0,0}という結果は、テンプレートで定義されたA₁, A₂にその値を代入することで「乱数η₁は2つの実行で常に同一値に揃える（θ[0]=1）、乱数η₂はif条件に入る場合は両者の差を1 - bq[i]に、入らない場合は0に設定する（θ[1]=1, θ[2]=0, θ[3]=-1, θ[4]=0, θ[5]=0, θ[6]=0）」という具体的な対応付けが得られます。この戦略によってプライバシー損失が厳密にϵ以下に抑えられることが証明されたわけです。 一方、反例が出力される場合、それは**「ある2つの入力と出力イベントの組」として提示されます。差分プライバシーにおける反例は通常「隣接する2つのデータベースxとx'が存在し、ある出力値oについてPr[M(x)=o]とPr[M(x')=o]の比がe^ϵを超える」という形で定義されます。CheckDPはこの定義に沿い、発見した無効化入力I（=(inp, inp᾽, sample)）から対応する出力事象oを構成して「Counterexample = (inp, inp᾽, o)」の形で報告します。上記BadGapSVTの例ではinpとinp᾽が具体的なリストデータ、oが特定の出力ビット列でした。この反例はPSIによる検証付きで出力されるため、ユーザはその入力を実際に機構Mに与えることでプライバシー違反を再現・確認できるという利点があります。なお、CheckDPは評価において既存手法が見逃していた微妙なバグを持つ機構にも反例を発見し、逆にこれまで形式的証明の報告がなかった正しい機構に新たな証明を与える**ことにも成功しています。証明も反例も自動で得られ、しかもCheckDPによる解析は非常に効率的で、正しい機構では平均70秒以内に証明生成、誤った機構では15秒以内に反例発見ができたと報告されています。
システム実装と使用ツール
CheckDPは上述のアプローチを実現するために、既存の強力な解析ツールを統合して用いています。以下に主要なコンポーネントと使用ツール、およびそれらの役割をまとめます。
Trans-compiler（コード変換コンポーネント）: まず、CheckDP独自の入力言語で記述された機構の疑似コードをパースし、前述したプログラム変換（乱数入力化、テンプレートとassertion挿入など）を行います。変換後のコードはC言語形式に落とし込まれ、CheckDP内部ではCプログラムとして扱われます（実際、チェック対象アルゴリズム群はGitHubで公開されているCheckDPリポジトリにCコードとして収録されています）。変換時には型環境Γに基づき距離変数の計算・伝搬を行い、適切な条件やassertion挿入をしています。また各関数のreturn直前にはassert(vϵ ≤ ϵ_bound)が自動挿入され、プライバシー予算内に収まっていることをチェックします。テンプレート生成アルゴリズム（Algorithm 1）もここで実行され、全てのアラインメントテンプレートA_i（およびθの穴）がコード中に埋め込まれます。
KLEE（シンボリック実行エンジン）: 検証サブループおよび無効化サブループの探索エンジンとして、KLEEが用いられています。KLEEはLLVMバイトコード上で動作するオープンソースのシンボリック実行ツールで、プログラム中のassertion違反を効率よく探索できます。CheckDPではKLEEに変換後プログラムM′を与え、assert文にぶつかる実行パスを見つけることで無効化入力Iを取得します。また、入力を固定してθをシンボリックにすることで「assertionを避けるθ」の探索にもKLEEを応用しています。探索効率のため、CheckDPはKLEEに対し「1つでもassertionに到達したら即座に探索を停止する（該当経路を報告する）」設定を行っています。これにより最も簡単にプライバシー違反を起こすケースを素早くキャッチできます。KLEEは完全な検証ツールではなく網羅性に欠ける可能性もありますが（理論上すべてのパスを探索できないため不完備である）、CheckDPでは後述のCPACheckerによる検証と併用することで問題を解決しています。実験上、KLEEの不完備さによる見逃しは発生しませんでした。なおKLEEは可変長リスト等の扱いが苦手なため、CheckDPの実装ではリスト長を一旦上限5に固定して探索し、証明や反例が得られた段階で必要に応じてリスト長を伸ばす工夫もしています。
CPAChecker（プログラム検証ツール）: CPACheckerはC言語プログラムの性質検証を行うツールで、モデルチェック技術を用いてassertionが全ての経路で満たされるかを形式的に確認できます。CheckDPではVerifierコンポーネントとしてCPACheckerを使用し、KLEEで得られた有望なθ（証明候補）を確定的に検証します。具体的には、θを定数に埋め込んだ変換後プログラムをCPACheckerに与え、assert(vϵ <= ϵ_bound)を含む全てのassertionが常に通ることをチェックします。CPACheckerはpredicateAnalysisモード等の設定で自動検証を行い、証明成功の場合は正常終了します。仮に失敗（assertion違反経路あり）の場合は、その具体的な入力トレース（カウンタ例）を出力する機能もあり、CheckDPはそれを新たな無効化入力としてループにフィードバックできる設計です。
PSI（精密確率解析ツール）: PSI（Probabilistic Symbolic Inference）は与えられた確率プログラムの出力分布を数式的に解析し、特定の事象の確率値を計算できるツールです
users.cs.duke.edu
。CheckDPでは反例候補が得られた際に、このPSIを用いて本当に差分プライバシー違反となっているかを検証します。具体的には、反例候補の入力ペア(inp, inp᾽)を機構Mに適用し、それぞれの出力が特定の値oをとる確率をPSIで計算します。そして$Pr[M(inp)=o]$と$Pr[M(inp᾽)=o]$の比を比較し、これが$e^ϵ$を超えていれば反例が確定します。PSIは数式的に誤差なく計算するため、サンプリングに頼る方法と異なり厳密な確認が可能です。CheckDPではPSIで確認された反例のみを出力することで、誤検知（フォールスポジティブ）のない信頼性を達成しています。
以上のように、CheckDPシステムは独自のプログラム変換・テンプレート生成ロジックと、KLEE・CPAChecker・PSIといった強力な解析ツール群を組み合わせることで、差分プライバシー証明と反例検出を統合的に実現しています。その結果、従来は手作業や莫大なサンプリング実行に頼っていたプライバシー検証を自動化し、短時間で正確に行えるようになっています。CheckDPは現時点で主要な差分プライバシー機構（Sparse Vector Technique系、Noisy Sum系など）の正当性検証および既知の不正実装のバグ検出に成功しており、今後も差分プライバシーアルゴリズムの安全性確認に寄与することが期待されています。
