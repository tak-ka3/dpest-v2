# CheckDP: 自動証明と反例生成による差分プライバシー検証

**出典**: Wang, Y., Ding, Z., Wang, G., Kifer, D., & Zhang, D. (2020). CheckDP: An Automated and Integrated Approach for Proving Differential Privacy or Finding Precise Counterexamples. *ACM CCS 2020*.

## 手法の概要

CheckDPは、差分プライバシー機構のソースコードと主張されるプライバシー予算εを入力として受け取り、**証明または反例のいずれかを自動生成**する統合的アプローチです。従来手法が「違反検出のみ」または「証明のみ」に特化していたのに対し、CheckDPは両方を一つの枠組みで実現します。

### 主要な特徴

1. **双方向探索**: 証明と反例の両方の空間を同時に探索
2. **ランダムネスアラインメント**: 乱数の対応付け（カップリング）を自動生成
3. **テンプレートベース合成**: パラメータ化されたアラインメント戦略を静的解析で生成
4. **形式検証ツールの統合**: KLEE、CPAChecker、PSIを組み合わせた自動検証
5. **精確な反例**: サンプリング誤差のない厳密な反例を提供

### 主要コンポーネント

CheckDPは以下のコンポーネントから構成されます：

1. **Trans-compiler（プログラム変換）**: 確率的プログラムを検証用プログラムに変換
2. **Template Generator（テンプレート生成）**: アラインメント戦略のテンプレートを自動生成
3. **Verify-Invalidate Loop（双方向探索）**: 証明候補と反例候補を交互に洗練
4. **Verifier（形式検証）**: CPACheckerによる完全性チェック
5. **Counterexample Validator（反例検証）**: PSIによる厳密な確率計算

## 手法の詳細を説明するにあたって必要な知識

### 1. ランダムネスアラインメント（Randomness Alignment）

**概念**: 隣接データベース $D_1, D_2$ に対する2回の実行において、**乱数の取り方を工夫**（カップリング）することで出力分布の差を抑え、差分プライバシーを証明する技法。

**例（Laplace機構）**:
- 素朴な実装: 各実行で独立に乱数をサンプリング
- アラインメント: **同じ乱数値を使用**することで、出力の差を入力の差のみに依存させる

### 2. テンプレート（Template）

**定義**: アラインメント戦略を表現するパラメータ付き数式。未知パラメータθを含む。

**例（GapSVTのテンプレート）**:
```
A₂ = if (q[i] + η₂ ≥ T_η)
       then (θ₀ + θ₁·T_bη + θ₂·bq[i])
       else (θ₃ + θ₄·T_bη + θ₅·bq[i])
```

ここで：
- `θ₀, ..., θ₅`: 未知パラメータ（自動探索）
- `T_bη`: 閾値ノイズの差分
- `bq[i]`: クエリ値の差分

### 3. Verify-Invalidate Loop

**アイデア**: CEGIS（Counterexample Guided Inductive Synthesis）の双方向拡張。

- **Verify側**: 証明候補θを改善
- **Invalidate側**: 反例候補Iを改善
- 両者を交互に洗練し、最終的にθまたはIのいずれかを確定

### 4. 使用ツール

- **KLEE**: シンボリック実行エンジン（assertion違反の探索）
- **CPAChecker**: プログラム検証ツール（全入力での正当性確認）
- **PSI**: 確率推論ツール（厳密な確率計算）

## CheckDPの動作フロー

### ステップ1: プログラム変換（静的解析）

元の確率的アルゴリズムを検証用プログラム $M'$ に変換：

1. **乱数の決定論的扱い**:
   ```python
   # 元のコード
   η := Lap(2/ε)

   # 変換後
   η := read_from(sample)  # 外部入力から読み取り
   ```

2. **アラインメントテンプレートの挿入**:
   ```python
   # 2つの実行での乱数の差
   Δη := η₁ - η₂
   # テンプレート適用
   Δη := A(θ, 条件, 変数)  # θは未知パラメータ
   ```

3. **プライバシーコスト変数の導入**:
   ```python
   v_ε := 0  # 初期化
   v_ε += |Δη| / r  # Laplace機構の寄与
   ```

4. **アサーションの挿入**:
   ```python
   assert(v_ε ≤ ε_bound)  # プライバシー予算チェック
   ```

**結果**: $M'(\text{inp}, \text{inp}', \text{sample}, θ)$ という決定論的プログラム

### ステップ2: アラインメントテンプレート生成

各乱数 $η_i$ に対して、テンプレート $A_i$ を自動生成：

**生成アルゴリズム**:
1. 関連条件集合 $E$ を抽出（分岐条件など）
2. 関連変数集合 $V$ を抽出（距離変数）
3. テンプレート構築:
   ```
   A = if e₀ then A₁(θ, V) else A₂(θ, V)
   ```
   where $A_i(θ, V) = θ_0 + θ_1·v_1 + ... + θ_n·v_n$

**例（GapSVT）**:
- 条件: `q[i] + η₂ ≥ T_η`
- 変数: `T_bη`, `bq[i]`
- テンプレート: 上述の条件分岐付き線形式

### ステップ3: Verify-Invalidate Loop

#### Verify Sub-loop（証明側）

**目標**: 全入力で assertion を通過する θ を見つける

**フェーズ1**: 無効化入力の探索
```
KLEE(M', θ_i固定) → assertion違反の入力 I_i を発見
```

**フェーズ2**: 証明候補の更新
```
∃θ. M'(I₀, θ) ∧ M'(I₁, θ) ∧ ... ∧ M'(I_i, θ)
→ 全無効化入力を満たす θ_{i+1} を探索
```

**検証**:
```
CPAChecker(M', θ_k) → 全入力で正当性を確認
→ 証明成功！
```

#### Invalidate Sub-loop（反例側）

**目標**: どんなθでも対処不可能な入力 I を見つける

**フェーズ1**: 証明候補の探索
```
∃θ. M'(I, θ) → この入力Iを救えるθがあるか？
```

**フェーズ2**: 反例入力の更新
```
∃I. ¬M'(I, θ₁) ∧ ... ∧ ¬M'(I, θ_i)
→ 全証明候補を破る新たな入力 I を探索
```

**検証**:
```
PSI(M, I) → P[M(D₁)∈E] / P[M(D₂)∈E] > e^ε ?
→ 反例確定！
```

### ステップ4: 結果出力

**証明の場合**:
- θの具体値（例: `{1, 1, 0, -1, 0, 0, 0}`）
- アラインメント戦略の完成形

**反例の場合**:
- 入力ペア: `(inp, inp')`
- 出力事象: `E`
- プライバシー損失: `log(P[M(D₁)∈E] / P[M(D₂)∈E])`

## 実験結果

### 証明生成の性能

| アルゴリズム | 結果 | 時間 |
|------------|------|------|
| GapSVT | 証明成功 | 70秒 |
| Laplace | 証明成功 | 15秒 |
| NoisyMax | 証明成功 | 45秒 |

### 反例発見の性能

| アルゴリズム | 結果 | 時間 |
|------------|------|------|
| BadGapSVT | 反例発見 | 15秒 |
| BrokenSVT | 反例発見 | 8秒 |

**発見された反例の例（BadGapSVT）**:
- 入力: `q = [0,0,0,0,0]`, `q' = [1,1,1,1,-1]`
- 閾値: `T = 0`
- 出力パターン: `[0,0,0,0,1]`
- プライバシー損失: `log(P/P') > ε`

## 他手法との比較

### StatDP / DP-Sniper との比較

| 特徴 | CheckDP | StatDP | DP-Sniper |
|------|---------|--------|-----------|
| 証明生成 | ✅ | ❌ | ❌ |
| 反例精度 | 厳密 | 統計的 | 統計的 |
| 実行時間 | 中（15-70秒） | 速（数秒） | 速（数秒） |
| サンプリング誤差 | なし | あり | あり |
| 完全性 | 形式検証付き | 不完全 | 不完全 |

### CheckDPの優位性

1. **証明と反例の統合**: 一つの枠組みで両方を生成
2. **精確な反例**: サンプリング誤差なし
3. **形式検証**: CPACheckerによる完全性保証
4. **自動化**: 手動での証明作業が不要

### CheckDPの制限

1. **計算コスト**: StatDP/DP-Sniperより遅い
2. **スケーラビリティ**: リスト長を制限（上限5など）
3. **表現力**: テンプレートで表現できない複雑なアラインメントは困難

## まとめ

CheckDPは、**ランダムネスアラインメントのテンプレート合成**と**双方向探索**により、差分プライバシー機構の証明と反例を自動生成する画期的な手法です。形式検証ツール（KLEE、CPAChecker、PSI）を統合することで、サンプリング誤差のない厳密な結果を提供します。

**主な貢献**:
1. 証明と反例の統合的アプローチ
2. テンプレートベースのアラインメント合成
3. Verify-Invalidate Loopによる効率的探索
4. 既知バグの検出と新規証明の生成に成功
